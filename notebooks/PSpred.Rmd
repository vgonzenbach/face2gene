---
title: "Predicting PS status with 22q characteristics"
author: "Virgilio Gonzenbach"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      cache = TRUE, 
                      cache.path = 'cache/PSpred/', 
                      fig.path = "figures/PSpred/")
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```


```{r load, include=FALSE}
library(dplyr)
library(tidyr)
library(FactoMineR)
library(factoextra)
library(pander)
library(pROC)
library(kableExtra)

chop_df = read.csv('data/Chop_merged_wideV_tp1.csv')
penn_df = read.csv("data/Penn_merged_wideV.csv")[,-1] %>% filter(group != "?") # 3 observations in '?' group
dat = read.csv('data/penn_chop_tp1_f2g_emotrics_passed_clean_030822.csv') # Read in extended data shared on March 2022

# Exclude columns with only zeros
get_zero_cols = function(df){
  num_zeros = df %>% sapply(function(x) x == 0) %>% colSums()
  prop_zeros = num_zeros / nrow(df)
  zero_cols = names(which(num_zeros == nrow(df)))
  return(zero_cols)
}

chop_df = chop_df %>% select(-all_of(get_zero_cols(chop_df)))
penn_df = penn_df %>% select(-all_of(get_zero_cols(penn_df)))

# Set seed for reproducibility
seed=42
set.seed(seed)
```

In this analysis, psychosis spectrum (PS) status is predicted based on 22q11.2 deletion syndrome (22q) characteristics.  

- First, PCA is performed on the 22q sample to estimate the relative contributions, i.e. the loadings, of each gestalt score to the axes of greatest variability (PCs) in this group.

- These loadings are then used to compute "22q-like" factor scores for the NC and PS groups: ROC analysis shows **PC2 alone correctly predicts PS status 67.8% of the time**.  

- Additionally, Leveneâ€™s test shows that **variance from the schizophrenia (SZ) group differs from that of clinical risk (CR) on PC2**.

## 0. Sample sizes

Sample sizes for face2gene scores and the original prediction task:

```{r}
comb_df = data.frame(case_id = c(chop_df$case_id, penn_df$case_id), group=c(chop_df$group, penn_df$group))
t(table(comb_df$group)) %>% kable(format="html") %>% kable_styling("striped", full_width = TRUE)
```

Total sample sizes in 03/08/22 data (first row) and non-missing data per variable:  

```{r}
# Get total in extended data
n_size = t(table(comb_df[comb_df$case_id %in% dat$case_id, "group"]))
vars= c("height", "weight", "GAF_C", "GAF_H", "MMSE", "VIQ", "PIQ", "FSIQ", "DSM.Dx", "PS")  
n_df = data.frame(case_id = dat$case_id, !is.na.data.frame(dat[,vars]))
n_df = merge(comb_df, n_df, by='case_id')
n_df = n_df %>% select(-case_id) %>% group_by(group) %>% summarize_all(sum)
n_tbl = rbind(n_size, t(n_df[,-1]))
n_tbl = cbind(n_tbl, rowSums(n_tbl))
colnames(n_tbl) = c(t(n_df)[1,], "total")
as.table(n_tbl) %>% kable(format="html") %>% kable_styling("striped", full_width = TRUE)
```

Note: Emotrics available for all records.

## 1. Examining characteristics of 22q sample with PCA

PCA was performed without scaling on the 22q sample alone.

### Scree Plot

```{r}
resPCA = PCA(chop_df[,-c(1:7)], scale.unit = FALSE, graph = FALSE, ncp=length(chop_df[,-c(1:7)]))
fviz_screeplot(resPCA)
```

Using the "elbow rule", subsequent analysis will focus on the first 4 PCs. 

### Loadings

Loadings for the first 2 PCs are plotted below.

```{r}
get_loadings = function(resPCA, dim=1){
  # Extract metrics from PCA object
  r = resPCA$var$coord[,dim] / sqrt(resPCA$eig[dim,1])
  
  # is equal to 
  return(r)
}

plot_loadings = function(resPCA, dim=1){
  # Plot loadings
  r = get_loadings(resPCA, dim)
  filter = r^2 > mean(r^2, na.rm = TRUE) # only include loadings with more than average contributions
  
  # Prep data
  df = data.frame(var=names(r), cor = r, row.names = NULL)[filter, ] %>% drop_na()
  df = df[order(df$cor, decreasing = TRUE),]
  df$var = factor(df$var, levels = rev(df$var)) #order before plotting
  
  # Plot
  title = sprintf("PC%s contributions", dim)
  p = df %>% ggplot(aes(x=var, y=cor)) + geom_col() + coord_flip() + 
    xlab("Gestalt Score") + ylab("Loading") + ggtitle(title) + 
    theme_bw() + theme(axis.text.y = element_text(size=10))
  return(p)
}
```

#### PC1

```{r, fig.width=12, fig.height=8}
plot_loadings(resPCA, dim=1)
```

#### PC2

```{r, fig.width=12, fig.height=8}
plot_loadings(resPCA, dim=2)
```

#### Scores and effects

```{r}
cov_df = data.frame(chop_df[, c("case_id", "sex", "age", "race")], PC1 = resPCA$ind$coord[, 1], PC2 = resPCA$ind$coord[, 2])
anova(lm(PC2 ~ sex + age + race, data=cov_df))
```

#### Sex

```{r}
cov_df %>% ggplot(aes(x=PC1, y=PC2, color = sex)) + geom_point() + 
  geom_point(data = cov_df %>% select(PC1, PC2, sex) %>% group_by(sex) %>%  summarize_all(mean), size = 4, shape = 17) + scale_color_manual(values = c("red", "blue")) + ggtitle("22q-like PC scores for 22q sample coded by sex")
```

#### Age

```{r, message=FALSE}
cov_df %>% ggplot(aes(x=age, y=PC2)) + geom_point() + geom_smooth(method='lm')
```

#### Emotrics correlations

PC2 scores were correlated with Brow Height (Left and Right), Marginal Reflex Distance 2 (Left and Right), and Philtrum measurements. 

```{r}
emotrics = c('Brow_Height_Right', 'Brow_Height_Left', 'Marginal_Reflex_Distance_1_Right', 'Marginal_Reflex_Distance_1_Left', 'Marginal_Reflex_Distance_2_Right', 'Marginal_Reflex_Distance_2_Left', 'Philtrum')
emotrics_df = dat %>% select(case_id, all_of(emotrics)) 

# Add emotrics to scores data.frame
cov_df = merge(cov_df, emotrics_df, by = 'case_id')
res = psych::corr.test(cov_df[, c("PC1", "PC2")], 
                       cov_df[, emotrics], 
                       adjust='fdr')

cor.mat = rbind(res$r[1,], 
                res$p.adj[1,], 
                res$r[2,], 
                res$p.adj[2,])

rownames(cor.mat) = c('PC1', 'p', 'PC2', 'p')
cor.mat %>% t() %>% kable(format = 'html') %>%  kable_styling("striped", full_width = TRUE)
sig.emotrics = names(which(cor.mat[4,] < .05))
```

## 2. Testing for differences in 22q-like factor scores between PS and NC

For the Penn sample (i.e. PS and NC groups), 2 factor scores are computed using the loadings above as weights in a linear combination of relevant gestalt scores (i.e. those gave hits in the 22q sample).

Note: any reference to PCs/factor scores below refers to those computed for the Penn sample. 

```{r}
demographics = c("bbl_id", "case_id", "sex", "race", "age", "age_at_photo")
df = penn_df %>% select(-c(all_of(demographics)))
df$group = recode(df$group, SZ = "PS", CR = "PS")

weigh_scores = function(df, coefs){
  #' Returns a linear combination of named scores included in 'coefs' 
  #' If named scores in coefs are not defined in df, columns are initialized with 0
  
  # which gestalt scores are missing from penn_df? i.e. PS and NC groups
  nohits = names(coefs)[which(!(names(coefs) %in% colnames(df)))] 
  df[, nohits] = 0 # set missing to zero to define columns
  
  # linear combination of gestalt scores
  scores.mat = as.matrix(df[, names(coefs)])
  weighted_score = as.vector(scores.mat %*% coefs)
  return(weighted_score)
}

weigh_scores2 = function(df, resPCA){
  # which gestalt scores are missing from penn_df? i.e. PS and NC groups
  nohits = rownames(resPCA$var$coord)[which(!(rownames(resPCA$var$coord) %in% colnames(df)))] 
  df[, nohits] = 0 # set missing to zero to define columns
   
  scores.mat = as.matrix(df[, rownames(resPCA$var$coord)]) 
  weighted_score = scores.mat %*% resPCA$svd$V
  
  return(weighted_score)
}
```

### PC 1

No significant differences between groups.

```{r}
scores_df = data.frame(group = df$group)
scores_df$PC1 = weigh_scores(df, get_loadings(resPCA, 1))
NC = df$group == "NC"
PS = df$group == "PS"

res.t.test = t.test(scores_df$PC1[PS], scores_df$PC1[NC])
names(res.t.test$estimate) = c("mean of NC", "mean of PS")
res.t.test
```

### PC 2

PC2 shows a difference between NC and PS groups.

```{r}
scores_df$PC2 = weigh_scores(df, get_loadings(resPCA, 2))

res.t.test = t.test(scores_df$PC2[NC], scores_df$PC2[PS])
names(res.t.test$estimate) = c("mean of NC", "mean of PS")
res.t.test
```

```{r}
scores_df %>% ggplot(aes(x=PC1, y=PC2, color = group)) + geom_point() + 
  geom_point(data = scores_df %>% group_by(group) %>% summarize_all(mean), size = 4, shape = 17) + scale_color_manual(values = c("dodgerblue", "salmon")) + ggtitle("22q-like PC Scores of Penn sample")
```


### SZ vs CR

We see a difference in variances on PC2.

```{r}
ps_df = data.frame(group = as.factor(penn_df$group),
          PC1 = scores_df$PC1, PC2 = scores_df$PC2) %>% filter(group!= "NC") 
ps_df %>% ggplot(aes(x=PC1, y=PC2, color = group)) + geom_point() + 
  geom_point(data = ps_df %>%  group_by(group) %>% summarize_all(mean), size = 4, shape = 17) + scale_color_manual(values = c("orange", "purple"))
```

#### PC2: T-test

```{r}
SZ = penn_df$group=="SZ"
CR = penn_df$group=="CR"

res.t.test = t.test(scores_df$PC2[SZ], scores_df$PC2[CR])
names(res.t.test$estimate) = c("mean of SZ", "mean of CR")
res.t.test
```

#### PC2: Levene's test

```{r}
car::leveneTest(ps_df$PC2, ps_df$group)
```

#### Emotrics

```{r}
# Order emotrics 
emo_df = merge(data.frame(case_id = penn_df$case_id, scores_df), emotrics_df, by='case_id')
# emo_df %>%  select(all_of(emotrics)) %>% lapply(bartlett.test, g=emo_df$group) # All variances are equal after adj
res.t = emo_df %>% select(all_of(emotrics)) %>% lapply(function(x) apa::t_test(x[df$group == 'PS'], x[df$group == 'NC'], var.equal=TRUE))

prt.st = function(grp, var, func){
  # Print stats
  round(func(emo_df[emo_df$group == grp , var]), 2)
}

report.t = function(res.t){
  #' Report t-test in apa format
  #'' TODO: to fully automate: print groups from data.name, bonus: add formatting/substutions of var.name as parameter
    for(dep.var in names(res.t)){
      
        cat(sprintf("- %s: PS (*M* = %s, *SD* = %s) and NC (*M* = %s, *SD* = %s), %s", 
                gsub("Right", "(R)", gsub("Left", "(L)", gsub("_", " ", dep.var))),
                round(mean(res.t[[dep.var]]$data$x), 2), round(sd(res.t[[dep.var]]$data$x), 2),
                round(mean(res.t[[dep.var]]$data$y), 2), round(sd(res.t[[dep.var]]$data$y), 2),
                apa::apa(res.t[[dep.var]], print = FALSE)), 
            sep="\n")
    }
}
```

For univariate t-tests, the only difference between groups was in Philtrum measurements:  

```{r, results='asis'}
report.t(res.t)
```


```{r, eval=FALSE}
- Brow Height (R): PS (M = `r prt.st("PS", "Brow_Height_Right", mean)`, SD = `r prt.st("PS", "Brow_Height_Right", sd)`), NC (`r prt.st("NC", "Brow_Height_Right", mean)`, SD = `r prt.st("NC", "Brow_Height_Right", sd)`), `r apa::apa(res.t.test[["Brow_Height_Right"]])`.  

- Brow Height (L): PS (M = `r prt.st("PS", "Brow_Height_Left", mean)`, SD = `r prt.st("PS", "Brow_Height_Left", sd)`), NC (`r prt.st("NC", "Brow_Height_Left", mean)`, SD = `r prt.st("NC", "Brow_Height_Left", sd)`), `r apa::apa(res.t.test[["Brow_Height_Left"]])`. 

- Marginal Reflex Distance 1 (R): PS (M = `r prt.st("PS", "Marginal_Reflex_Distance_1_Right", mean)`, SD = `r prt.st("PS", "Marginal_Reflex_Distance_1_Right", sd)`), NC (`r prt.st("NC", "Marginal_Reflex_Distance_1_Right", mean)`, SD = `r prt.st("NC", "Marginal_Reflex_Distance_1_Right", sd)`), `r apa::apa(res.t.test[["Marginal_Reflex_Distance_1_Right"]])`.  

- Marginal Reflex Distance 1 (L): PS (M = `r prt.st("PS", "Marginal_Reflex_Distance_1_Left", mean)`, SD = `r prt.st("PS", "Marginal_Reflex_Distance_1_Left", sd)`), NC (`r prt.st("NC", "Marginal_Reflex_Distance_1_Left", mean)`, SD = `r prt.st("NC", "Marginal_Reflex_Distance_1_Left", sd)`), `r apa::apa(res.t.test[["Marginal_Reflex_Distance_1_Left"]])`.  

- Marginal Reflex Distance 2 (R): `r apa::apa(res.t.test[["Marginal_Reflex_Distance_2_Right"]])`.  
- Marginal Reflex Distance 2 (L): `r apa::apa(res.t.test[["Marginal_Reflex_Distance_2_Left"]])`.  
- Philtrum: `r apa::apa(res.t.test[["Philtrum"]])`.  

```


## 3. Predicting PS status based on 22q-like PC2

```{r}
plotROCs = function(roc1, roc2, main, legends){
  plot(roc1, col="blue", main=main)
  plot(roc2, col="red", add=TRUE)
  legend("bottomright", 
    legend = legends, 
    col = c("blue", "red"), 
    pch = c(17,19), 
    bty = "n", 
    pt.cex = 2, 
    cex = 1.2, 
    text.col = "black", 
    horiz = F , 
    inset = c(0.1, 0.1))
  roc.test(roc1, roc2, method = "delong")
}
```

```{r, message=FALSE}
resROCPC2 = roc(group ~ PC2, data=scores_df)
plot(resROCPC2, main = sprintf("PC2 predictive of PS status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

### SZ and CR

Focusing the prediction on PS subgroups, results are similar to predicting on the aggregated PS group.

#### Schizophrenia (SZ)

```{r, message=FALSE}
sz_df = data.frame(group = penn_df$group, PC2 = scores_df$PC2) %>% filter(group != 'CR')
resROCPC2 = roc(group ~ PC2, data=sz_df)
plot(resROCPC2, main = sprintf("PC2 predictive of SZ status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

#### Clinical Risk (CR)

```{r, message=FALSE}
cr_df = data.frame(group = penn_df$group, PC2 = scores_df$PC2) %>% filter(group != 'SZ')
resROCPC2 = roc(group ~ PC2, data=cr_df)
plot(resROCPC2, main = sprintf("PC2 predictive of CR status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

## 4. Predicting PS status based on adjusted PC2 

### Sex- and -age adjustment

Prediction strength for PS status drops slightly after adjustment. However, prediction of CR status becomes essentially random post-adjustment.

```{r, message=FALSE}
cov_df = data.frame(scores_df, penn_df[, c("case_id", "sex", "age", "race")])
cov_df$PC2 = residuals(lm(PC2 ~ sex + age, data=cov_df))
resROCPC2 = roc(group ~ PC2, data=cov_df)
plot(resROCPC2, main = sprintf("PC2 predictive of PS status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

#### Schizophrenia (SZ)

```{r, message=FALSE}
sz_df = data.frame(group = penn_df$group, PC2 = cov_df$PC2) %>% filter(group != 'CR')
resROCPC2 = roc(group ~ PC2, data=sz_df)
plot(resROCPC2, main = sprintf("PC2 predictive of SZ status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

#### Clinical Risk (CR)

```{r, message=FALSE}
cr_df = data.frame(group = penn_df$group, PC2 = cov_df$PC2) %>% filter(group != 'SZ')
resROCPC2 = roc(group ~ PC2, data=cr_df)
plot(resROCPC2, main = sprintf("PC2 predictive of CR status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

### Emotrics-adjusted scores

After adjusting PC2 for emotrics, prediction of SZ-status remains strong while CR becomes random.

```{r, message=FALSE}
emo_df$PC2 = residuals(lm(formula(sprintf("%s ~ %s", 
                                          "PC2", 
                                          paste(sig.emotrics, collapse=" + "))), 
                          data=emo_df))
resROCPC2 = roc(group ~ PC2, data=emo_df)
plot(resROCPC2, main = sprintf("PC2 predictive of PS status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

#### Schizophrenia (SZ)

```{r, message=FALSE}
sz_df = merge(penn_df[, c("case_id", "group")], emo_df[,c("case_id", "PC2")]) %>% filter(group != 'CR')
resROCPC2 = roc(group ~ PC2, data=sz_df)
plot(resROCPC2, main = sprintf("PC2 predictive of SZ status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

#### Clinical Risk (CR)

```{r, message=FALSE}
cr_df = merge(penn_df[, c("case_id", "group")], emo_df[,c("case_id", "PC2")]) %>% filter(group != 'SZ')
resROCPC2 = roc(group ~ PC2, data=cr_df)
plot(resROCPC2, main = sprintf("PC2 predictive of CR status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

## Conclusion

- PC2 alone is predictive of PS status with an AUC of `r round(pROC::auc(resROCPC2), 3)`!
- There are variance differences on PC2 between PS groups (SZ vs CR).
- After adjustments, Schizophrenia (SZ) status remains well-predicted while Clinical Risk (CR) status does not.
