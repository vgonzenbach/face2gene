---
title: "Predicting PS status with 22q characteristics"
author: "Virgilio Gonzenbach"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      cache = TRUE, 
                      cache.path = 'cache/PSpred/', 
                      fig.path = "figures/PSpred/")
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```


```{r load, include=FALSE}
library(dplyr)
library(tidyr)
library(FactoMineR)
library(factoextra)
library(pander)
library(pROC)
library(kableExtra)

chop_df = read.csv('data/Chop_merged_wideV_tp1.csv')
penn_df = read.csv("data/Penn_merged_wideV.csv")[,-1] %>% filter(group != "?") # 3 observations in '?' group

# Exclude columns with only zeros
get_zero_cols = function(df){
  num_zeros = df %>% sapply(function(x) x == 0) %>% colSums()
  prop_zeros = num_zeros / nrow(df)
  zero_cols = names(which(num_zeros == nrow(df)))
  return(zero_cols)
}

chop_df = chop_df %>% select(-all_of(get_zero_cols(chop_df)))
penn_df = penn_df %>% select(-all_of(get_zero_cols(penn_df)))

# Set seed for reproducibility
seed=42
set.seed(seed)
```


In this analysis, psychosis spectrum (PS) status is predicted based on 22q11.2 deletion syndrome (22q) characteristics.  

- First, PCA is performed on the 22q sample to estimate the relative contributions, i.e. the loadings, of each gestalt score to the axes of greatest variability (PCs) in this group.

- These loadings are then used to compute "22q-like" factor scores for the NC and PS groups: ROC analysis shows **PC2 alone correctly predicts PS status 67.8% of the time**.  

- Additionally, Leveneâ€™s test shows that **variance from the schizophrenia (SZ) group differs from that of clinical risk (CR) on PC2**.

## 0. Sample sizes

```{r}
t(table(c(chop_df$group, penn_df$group))) %>% kable(format="html") %>% kable_styling("striped", full_width = TRUE)
```

## 1. Examining characteristics of 22q sample with PCA

PCA was performed without scaling on the 22q sample alone.

### Scree Plot

```{r}
resPCA = PCA(chop_df[,-c(1:7)], scale.unit = FALSE, graph = FALSE, ncp=length(chop_df[,-c(1:7)]))
fviz_screeplot(resPCA)
```

Using the "elbow rule", subsequent analysis will focus on the first 4 PCs. 

### Loadings

Loadings for the first 2 PCs are plotted below.

```{r}
get_loadings = function(resPCA, dim=1){
  # Extract metrics from PCA object
  r = resPCA$var$coord[,dim] / sqrt(resPCA$eig[dim,1])
  
  # is equal to 
  return(r)
}

plot_loadings = function(resPCA, dim=1){
  # Plot loadings
  r = get_loadings(resPCA, dim)
  filter = r^2 > mean(r^2, na.rm = TRUE) # only include loadings with more than average contributions
  
  # Prep data
  df = data.frame(var=names(r), cor = r, row.names = NULL)[filter, ] %>% drop_na()
  df = df[order(df$cor, decreasing = TRUE),]
  df$var = factor(df$var, levels = rev(df$var)) #order before plotting
  
  # Plot
  title = sprintf("PC%s contributions", dim)
  p = df %>% ggplot(aes(x=var, y=cor)) + geom_col() + coord_flip() + 
    xlab("Gestalt Score") + ylab("Loading") + ggtitle(title) + 
    theme_bw() + theme(axis.text.y = element_text(size=10))
  return(p)
}
```

#### PC1

```{r, fig.width=12, fig.height=8}
plot_loadings(resPCA, dim=1)
```

#### PC2

```{r, fig.width=12, fig.height=8}
plot_loadings(resPCA, dim=2)
```

### Scores

```{r}
x22q_df = data.frame(PC1 = resPCA$ind$coord[, 1], PC2 = resPCA$ind$coord[, 2])
x22q_df %>% ggplot(aes(x=PC1, y=PC2)) + geom_point() 
```

## 2. Testing for differences in 22q-like factor scores between PS and NC

For the Penn sample (i.e. PS and NC groups), 2 factor scores are computed using the loadings above as weights in a linear combination of relevant gestalt scores (i.e. those gave hits in the 22q sample).

Note: any reference to PCs/factor scores below refers to those computed for the Penn sample. 

```{r}
demographics = c("bbl_id", "case_id", "sex", "race", "age", "age_at_photo")
df = penn_df %>% select(-c(all_of(demographics)))
df$group = recode(df$group, SZ = "PS", CR = "PS")

weigh_scores = function(df, coefs){
  #' Returns a linear combination of named scores included in 'coefs' 
  #' If named scores in coefs are not defined in df, columns are initialized with 0
  
  # which gestalt scores are missing from penn_df? i.e. PS and NC groups
  nohits = names(coefs)[which(!(names(coefs) %in% colnames(df)))] 
  df[, nohits] = 0 # set missing to zero to define columns
  
  # linear combination of gestalt scores
  scores.mat = as.matrix(df[, names(coefs)])
  weighted_score = as.vector(scores.mat %*% coefs)
  return(weighted_score)
}

weigh_scores2 = function(df, resPCA){
  # which gestalt scores are missing from penn_df? i.e. PS and NC groups
  nohits = rownames(resPCA$var$coord)[which(!(rownames(resPCA$var$coord) %in% colnames(df)))] 
  df[, nohits] = 0 # set missing to zero to define columns
   
  scores.mat = as.matrix(df[, rownames(resPCA$var$coord)]) 
  weighted_score = scores.mat %*% resPCA$svd$V
  
  return(weighted_score)
}
```

### PC 1

No significant differences between groups.

```{r}
scores_df = data.frame(group = df$group)
scores_df$PC1 = weigh_scores(df, get_loadings(resPCA, 1))
NC = df$group == "NC"
PS = df$group == "PS"

res.t.test = t.test(scores_df$PC1[NC], scores_df$PC1[PS])
names(res.t.test$estimate) = c("mean of NC", "mean of PS")
res.t.test
```

### PC 2

PC2 shows a difference between NC and PS groups.

```{r}
scores_df$PC2 = weigh_scores(df, get_loadings(resPCA, 2))

res.t.test = t.test(scores_df$PC2[NC], scores_df$PC2[PS])
names(res.t.test$estimate) = c("mean of NC", "mean of PS")
res.t.test
```

```{r}
scores_df %>% ggplot(aes(x=PC1, y=PC2, color = group)) + geom_point() + 
  geom_point(data = scores_df %>% group_by(group) %>% summarize_all(mean), size = 4, shape = 17) + scale_color_manual(values = c("dodgerblue", "salmon")) + ggtitle("22q-like PC Scores of Penn sample")
```


### SZ vs CR

We see a difference in variances on PC2.

```{r}
ps_df = data.frame(group = as.factor(penn_df$group),
          PC1 = scores_df$PC1, PC2 = scores_df$PC2) %>% filter(group!= "NC") 
ps_df %>% ggplot(aes(x=PC1, y=PC2, color = group)) + geom_point() + 
  geom_point(data = ps_df %>%  group_by(group) %>% summarize_all(mean), size = 4, shape = 17) + scale_color_manual(values = c("orange", "purple"))
```

#### PC2: T-test

```{r}
SZ = penn_df$group=="SZ"
CR = penn_df$group=="CR"

res.t.test = t.test(scores_df$PC2[SZ], scores_df$PC2[CR])
names(res.t.test$estimate) = c("mean of SZ", "mean of CR")
res.t.test
```

#### PC2: Levene's test

```{r}
car::leveneTest(ps_df$PC2, ps_df$group)
```

## 3. Predicting PS status based on 22q-like PC2

```{r}
plotROCs = function(roc1, roc2, main, legends){
  plot(roc1, col="blue", main=main)
  plot(roc2, col="red", add=TRUE)
  legend("bottomright", 
    legend = legends, 
    col = c("blue", "red"), 
    pch = c(17,19), 
    bty = "n", 
    pt.cex = 2, 
    cex = 1.2, 
    text.col = "black", 
    horiz = F , 
    inset = c(0.1, 0.1))
  roc.test(roc1, roc2, method = "delong")
}
```

```{r, message=FALSE}
resROCPC2 = roc(group ~ PC2, data=scores_df)
plot(resROCPC2, main = sprintf("PC2 predictive of PS status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```




### SZ and CR

Focusing the prediction on PS subgroups, results are similar to predicting on the aggregated PS group.

#### Schizophrenia (SZ)

```{r, message=FALSE}
sz_df = data.frame(group = penn_df$group, PC2 = scores_df$PC2) %>% filter(group != 'CR')
resROCPC2 = roc(group ~ PC2, data=sz_df)
plot(resROCPC2, main = sprintf("PC2 predictive of SZ status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

#### Clinical Risk (CR)

```{r, message=FALSE}
cr_df = data.frame(group = penn_df$group, PC2 = scores_df$PC2) %>% filter(group != 'SZ')
resROCPC2 = roc(group ~ PC2, data=cr_df)
plot(resROCPC2, main = sprintf("PC2 predictive of CR status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

## 4. Association of PC2 with demographics and phenotypic information

PC2 is associated with age and sex.

```{r}
cov_df = data.frame(PC1 = scores_df$PC1, PC2 = scores_df$PC2, penn_df[, c("group", "sex", "age", "race")])
anova(lm(PC2 ~ sex + age + race + group, data=cov_df))
```

#### Sex

```{r}
cov_df %>% ggplot(aes(x=PC1, y=PC2, color = sex)) + geom_point() + 
  geom_point(data = cov_df %>% select(PC1, PC2, sex) %>% group_by(sex) %>%  summarize_all(mean), size = 4, shape = 17) + scale_color_manual(values = c("red", "blue")) + ggtitle("22q-like PC scores for Penn sample coded by sex")
```

#### Age

```{r, message=FALSE}
cov_df %>% ggplot(aes(x=age, y=PC2)) + geom_point() + geom_smooth(method='lm')
```

## 5. Predicting PS status based on sex- and age-adjusted PC2 

Prediction strength for PS status drops slightly after adjustment. However, prediction of CR status becomes essentially random post-adjustment.

```{r, message=FALSE}
scores_df$PC2 = residuals(lm(PC2 ~ sex + age, data=cov_df))
resROCPC2 = roc(group ~ PC2, data=scores_df)
plot(resROCPC2, main = sprintf("PC2 predictive of PS status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

#### Schizophrenia (SZ)

```{r, message=FALSE}
sz_df = data.frame(group = penn_df$group, PC2 = scores_df$PC2) %>% filter(group != 'CR')
resROCPC2 = roc(group ~ PC2, data=sz_df)
plot(resROCPC2, main = sprintf("PC2 predictive of SZ status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

#### Clinical Risk (CR)

```{r, message=FALSE}
cr_df = data.frame(group = penn_df$group, PC2 = scores_df$PC2) %>% filter(group != 'SZ')
resROCPC2 = roc(group ~ PC2, data=cr_df)
plot(resROCPC2, main = sprintf("PC2 predictive of CR status (AUC = %s)", round(auc(resROCPC2),3)))
ci(resROCPC2)
```

## Conclusion

- PC2 alone is predictive of PS status with an AUC of `r round(pROC::auc(resROCPC2), 3)`!
- There are variance differences on PC2 between PS groups (SZ vs CR).
